{
    // Object Pool Snippets
    "Dreamcast Object Pool": {
        "prefix": "dcpool",
        "body": [
            "typedef struct {",
            "    ${1:EntityType} pool[${2:MAX_ENTITIES}];",
            "    uint32_t active_flags[(${2:MAX_ENTITIES} + 31) / 32];",
            "    uint16_t active_count;",
            "    uint16_t next_free;",
            "} ${1:EntityType}Pool;",
            "",
            "static ${1:EntityType}Pool ${3:entity}_pool;",
            "",
            "${1:EntityType}* ${3:entity}_pool_allocate(void) {",
            "    if (${3:entity}_pool.active_count >= ${2:MAX_ENTITIES}) return NULL;",
            "    ",
            "    for (int i = 0; i < ${2:MAX_ENTITIES}; i++) {",
            "        int word = i / 32;",
            "        int bit = i % 32;",
            "        if (!(${3:entity}_pool.active_flags[word] & (1 << bit))) {",
            "            ${3:entity}_pool.active_flags[word] |= (1 << bit);",
            "            ${3:entity}_pool.active_count++;",
            "            return &${3:entity}_pool.pool[i];",
            "        }",
            "    }",
            "    return NULL;",
            "}",
            "",
            "void ${3:entity}_pool_free(${1:EntityType}* entity) {",
            "    int index = entity - ${3:entity}_pool.pool;",
            "    int word = index / 32;",
            "    int bit = index % 32;",
            "    ${3:entity}_pool.active_flags[word] &= ~(1 << bit);",
            "    ${3:entity}_pool.active_count--;",
            "}"
        ],
        "description": "Create a complete object pool implementation"
    },
    // Fixed-Point Math Snippets
    "Fixed-Point Type": {
        "prefix": "dcfixed",
        "body": [
            "#define FIXED_SHIFT ${1:16}",
            "#define FIXED_ONE (1 << FIXED_SHIFT)",
            "#define FLOAT_TO_FIXED(x) ((int32_t)((x) * FIXED_ONE))",
            "#define FIXED_TO_FLOAT(x) ((float)(x) / FIXED_ONE)",
            "#define INT_TO_FIXED(x) ((x) << FIXED_SHIFT)",
            "#define FIXED_TO_INT(x) ((x) >> FIXED_SHIFT)",
            "",
            "typedef int32_t fixed${1:16}_t;"
        ],
        "description": "Define fixed-point math types and conversion macros"
    },
    "Fixed-Point Operations": {
        "prefix": "dcfixops",
        "body": [
            "// Fixed-point multiplication",
            "static inline fixed16_t fixed_mul(fixed16_t a, fixed16_t b) {",
            "    return (fixed16_t)(((int64_t)a * b) >> 16);",
            "}",
            "",
            "// Fixed-point division",
            "static inline fixed16_t fixed_div(fixed16_t a, fixed16_t b) {",
            "    return (fixed16_t)(((int64_t)a << 16) / b);",
            "}",
            "",
            "// Fixed-point square root (approximation)",
            "static inline fixed16_t fixed_sqrt(fixed16_t x) {",
            "    if (x <= 0) return 0;",
            "    ",
            "    fixed16_t result = x;",
            "    fixed16_t last;",
            "    ",
            "    do {",
            "        last = result;",
            "        result = (result + fixed_div(x, result)) >> 1;",
            "    } while (abs(result - last) > 1);",
            "    ",
            "    return result;",
            "}"
        ],
        "description": "Common fixed-point math operations"
    },
    // Memory-Aligned Structure
    "Dreamcast Aligned Structure": {
        "prefix": "dcstruct",
        "body": [
            "typedef struct __attribute__((aligned(32))) {",
            "    ${1:// Hot data - accessed every frame}",
            "    $0",
            "} ${2:StructName};",
            "",
            "// Ensure proper alignment",
            "_Static_assert(sizeof(${2:StructName}) % 32 == 0, \"${2:StructName} must be 32-byte aligned\");"
        ],
        "description": "Create a 32-byte aligned structure for DMA efficiency"
    },
    // Performance Profiling
    "Performance Timer": {
        "prefix": "dcprof",
        "body": [
            "#ifdef DEBUG",
            "    #define PROF_START(name) \\\\",
            "        uint64_t _prof_##name##_start = timer_us_gettime64()",
            "    #define PROF_END(name) \\\\",
            "        printf(#name \": %llu us\\\\n\", timer_us_gettime64() - _prof_##name##_start)",
            "#else",
            "    #define PROF_START(name)",
            "    #define PROF_END(name)",
            "#endif"
        ],
        "description": "Performance profiling macros"
    },
    // Sprite Batch
    "Sprite Batch System": {
        "prefix": "dcbatch",
        "body": [
            "typedef struct {",
            "    pvr_sprite_txr_t sprites[${1:MAX_BATCH_SIZE}];",
            "    int count;",
            "    pvr_ptr_t texture;",
            "} SpriteBatch;",
            "",
            "static SpriteBatch sprite_batch;",
            "",
            "void batch_begin(pvr_ptr_t texture) {",
            "    sprite_batch.count = 0;",
            "    sprite_batch.texture = texture;",
            "}",
            "",
            "void batch_add_sprite(float x, float y, float w, float h) {",
            "    if (sprite_batch.count >= ${1:MAX_BATCH_SIZE}) {",
            "        batch_flush();",
            "    }",
            "    ",
            "    pvr_sprite_txr_t* spr = &sprite_batch.sprites[sprite_batch.count++];",
            "    pvr_sprite_cxt_txr(spr, PVR_LIST_TR_POLY,",
            "                       PVR_TXRFMT_RGB565 | PVR_TXRFMT_TWIDDLED,",
            "                       ${2:256}, ${3:256}, sprite_batch.texture,",
            "                       PVR_FILTER_BILINEAR);",
            "    ",
            "    spr->ax = x; spr->ay = y;",
            "    spr->bx = x + w; spr->by = y;",
            "    spr->cx = x + w; spr->cy = y + h;",
            "    spr->dx = x; spr->dy = y + h;",
            "}",
            "",
            "void batch_flush(void) {",
            "    pvr_list_begin(PVR_LIST_TR_POLY);",
            "    for (int i = 0; i < sprite_batch.count; i++) {",
            "        pvr_prim(&sprite_batch.sprites[i], sizeof(pvr_sprite_txr_t));",
            "    }",
            "    pvr_list_finish();",
            "    sprite_batch.count = 0;",
            "}"
        ],
        "description": "Complete sprite batching system"
    },
    // Memory Tracking
    "Memory Usage Tracker": {
        "prefix": "dcmem",
        "body": [
            "typedef enum {",
            "    MEM_GAME_LOGIC,",
            "    MEM_RENDERING,",
            "    MEM_AUDIO,",
            "    MEM_ENTITIES,",
            "    MEM_TEXTURES,",
            "    MEM_COUNT",
            "} MemCategory;",
            "",
            "static size_t mem_usage[MEM_COUNT] = {0};",
            "static const char* mem_names[MEM_COUNT] = {",
            "    \"Game Logic\",",
            "    \"Rendering\",",
            "    \"Audio\",",
            "    \"Entities\",",
            "    \"Textures\"",
            "};",
            "",
            "void* tracked_malloc(size_t size, MemCategory cat) {",
            "    void* ptr = memalign(32, size);",
            "    if (ptr) {",
            "        mem_usage[cat] += size;",
            "    }",
            "    return ptr;",
            "}",
            "",
            "void tracked_free(void* ptr, size_t size, MemCategory cat) {",
            "    if (ptr) {",
            "        free(ptr);",
            "        mem_usage[cat] -= size;",
            "    }",
            "}",
            "",
            "void print_memory_report(void) {",
            "    printf(\"=== Memory Usage Report ===\\\\n\");",
            "    size_t total = 0;",
            "    for (int i = 0; i < MEM_COUNT; i++) {",
            "        printf(\"%s: %zu KB\\\\n\", mem_names[i], mem_usage[i] / 1024);",
            "        total += mem_usage[i];",
            "    }",
            "    printf(\"Total: %zu KB / 16384 KB (%.1f%%)\\\\n\",",
            "           total / 1024, (float)total / (16 * 1024 * 1024) * 100.0f);",
            "}"
        ],
        "description": "Memory usage tracking system"
    },
    // Controller Input
    "Controller Handler": {
        "prefix": "dcinput",
        "body": [
            "typedef struct {",
            "    uint32_t buttons;",
            "    uint32_t last_buttons;",
            "    float analog_x;",
            "    float analog_y;",
            "    float ltrigger;",
            "    float rtrigger;",
            "} PlayerInput;",
            "",
            "static PlayerInput player_inputs[4];",
            "",
            "void update_player_input(int player) {",
            "    if (!maple_device_func(player, MAPLE_FUNC_CONTROLLER)) return;",
            "    ",
            "    cont_state_t* state = (cont_state_t*)maple_dev_status(player);",
            "    if (!state) return;",
            "    ",
            "    PlayerInput* input = &player_inputs[player];",
            "    input->last_buttons = input->buttons;",
            "    input->buttons = state->buttons;",
            "    ",
            "    // Analog stick (-128 to 127)",
            "    input->analog_x = (float)state->joyx / 128.0f;",
            "    input->analog_y = (float)state->joyy / 128.0f;",
            "    ",
            "    // Triggers (0 to 255)",
            "    input->ltrigger = (float)state->ltrig / 255.0f;",
            "    input->rtrigger = (float)state->rtrig / 255.0f;",
            "}",
            "",
            "bool is_button_pressed(int player, uint32_t button) {",
            "    PlayerInput* input = &player_inputs[player];",
            "    return (input->buttons & button) && !(input->last_buttons & button);",
            "}",
            "",
            "bool is_button_held(int player, uint32_t button) {",
            "    return player_inputs[player].buttons & button;",
            "}"
        ],
        "description": "Complete controller input handling system"
    },
    // Texture Loading
    "Load PVR Texture": {
        "prefix": "dctexture",
        "body": [
            "pvr_ptr_t load_pvr_texture(const char* filename, uint32_t* out_width, uint32_t* out_height) {",
            "    FILE* fp = fopen(filename, \"rb\");",
            "    if (!fp) {",
            "        printf(\"Failed to open texture: %s\\\\n\", filename);",
            "        return NULL;",
            "    }",
            "    ",
            "    // Read PVR header",
            "    struct {",
            "        char id[4];",
            "        uint32_t size;",
            "        uint8_t type;",
            "        uint8_t format;",
            "        uint16_t width;",
            "        uint16_t height;",
            "    } header;",
            "    ",
            "    fread(&header, sizeof(header), 1, fp);",
            "    ",
            "    // Allocate VRAM",
            "    pvr_ptr_t texture = pvr_mem_malloc(header.size);",
            "    if (!texture) {",
            "        fclose(fp);",
            "        return NULL;",
            "    }",
            "    ",
            "    // Load texture data",
            "    void* temp = malloc(header.size);",
            "    fread(temp, header.size, 1, fp);",
            "    pvr_txr_load(temp, texture, header.size);",
            "    free(temp);",
            "    ",
            "    fclose(fp);",
            "    ",
            "    if (out_width) *out_width = header.width;",
            "    if (out_height) *out_height = header.height;",
            "    ",
            "    return texture;",
            "}"
        ],
        "description": "Load a PVR texture into VRAM"
    },
    // Frame Rate Limiter
    "Frame Rate Control": {
        "prefix": "dcfps",
        "body": [
            "typedef struct {",
            "    uint64_t last_frame_time;",
            "    uint64_t frame_times[60];",
            "    int frame_index;",
            "    float average_fps;",
            "} FrameRateController;",
            "",
            "static FrameRateController fps_controller = {0};",
            "",
            "void fps_begin_frame(void) {",
            "    fps_controller.last_frame_time = timer_us_gettime64();",
            "}",
            "",
            "void fps_end_frame(void) {",
            "    uint64_t current_time = timer_us_gettime64();",
            "    uint64_t frame_time = current_time - fps_controller.last_frame_time;",
            "    ",
            "    // Store frame time",
            "    fps_controller.frame_times[fps_controller.frame_index] = frame_time;",
            "    fps_controller.frame_index = (fps_controller.frame_index + 1) % 60;",
            "    ",
            "    // Calculate average FPS",
            "    uint64_t total_time = 0;",
            "    for (int i = 0; i < 60; i++) {",
            "        total_time += fps_controller.frame_times[i];",
            "    }",
            "    fps_controller.average_fps = 60000000.0f / (float)total_time;",
            "    ",
            "    // Wait for target frame time (16667 us for 60 FPS)",
            "    const uint64_t target_frame_time = 16667;",
            "    if (frame_time < target_frame_time) {",
            "        timer_spin_sleep((target_frame_time - frame_time) / 1000);",
            "    }",
            "}",
            "",
            "float fps_get_average(void) {",
            "    return fps_controller.average_fps;",
            "}"
        ],
        "description": "Frame rate control and monitoring"
    },
    // Debug Overlay
    "Debug Overlay": {
        "prefix": "dcdebug",
        "body": [
            "#ifdef DEBUG",
            "typedef struct {",
            "    bool show_fps;",
            "    bool show_memory;",
            "    bool show_entities;",
            "    bool show_collision;",
            "} DebugFlags;",
            "",
            "static DebugFlags debug_flags = {true, true, false, false};",
            "",
            "void debug_draw_overlay(void) {",
            "    int y = 10;",
            "    ",
            "    if (debug_flags.show_fps) {",
            "        char fps_text[32];",
            "        sprintf(fps_text, \"FPS: %.1f\", fps_get_average());",
            "        draw_text(fps_text, 10, y, 0xFFFFFF00);",
            "        y += 20;",
            "    }",
            "    ",
            "    if (debug_flags.show_memory) {",
            "        size_t free_mem = mallinfo_free_mem();",
            "        char mem_text[64];",
            "        sprintf(mem_text, \"Free RAM: %zu KB\", free_mem / 1024);",
            "        draw_text(mem_text, 10, y, 0xFFFFFF00);",
            "        y += 20;",
            "    }",
            "    ",
            "    if (debug_flags.show_entities) {",
            "        char entity_text[64];",
            "        sprintf(entity_text, \"Entities: %d / %d\", ",
            "                get_active_entity_count(), MAX_ENTITIES);",
            "        draw_text(entity_text, 10, y, 0xFFFFFF00);",
            "        y += 20;",
            "    }",
            "}",
            "",
            "void debug_toggle_flag(DebugFlags* flag) {",
            "    *flag = !*flag;",
            "}",
            "#else",
            "    #define debug_draw_overlay()",
            "    #define debug_toggle_flag(x)",
            "#endif"
        ],
        "description": "Debug overlay system"
    },
    // Collision Detection
    "AABB Collision": {
        "prefix": "dcaabb",
        "body": [
            "typedef struct {",
            "    fixed16_t x, y;",
            "    fixed16_t w, h;",
            "} AABB;",
            "",
            "bool aabb_intersects(const AABB* a, const AABB* b) {",
            "    return (a->x < b->x + b->w &&",
            "            a->x + a->w > b->x &&",
            "            a->y < b->y + b->h &&",
            "            a->y + a->h > b->y);",
            "}",
            "",
            "bool aabb_contains_point(const AABB* box, fixed16_t x, fixed16_t y) {",
            "    return (x >= box->x && x < box->x + box->w &&",
            "            y >= box->y && y < box->y + box->h);",
            "}",
            "",
            "void aabb_get_center(const AABB* box, fixed16_t* cx, fixed16_t* cy) {",
            "    *cx = box->x + (box->w >> 1);",
            "    *cy = box->y + (box->h >> 1);",
            "}"
        ],
        "description": "Axis-aligned bounding box collision detection"
    },
    // Entity Component
    "Entity Component": {
        "prefix": "dcentity",
        "body": [
            "typedef struct __attribute__((aligned(32))) {",
            "    // Transform component",
            "    fixed16_t x, y;",
            "    fixed16_t vx, vy;",
            "    ",
            "    // Sprite component",
            "    uint16_t sprite_id;",
            "    uint16_t animation_frame;",
            "    ",
            "    // Game component",
            "    uint16_t type;",
            "    uint16_t health;",
            "    uint32_t flags;",
            "    ",
            "    // Padding to 32 bytes",
            "    uint8_t _padding[8];",
            "} Entity;",
            "",
            "// Entity flags",
            "#define ENTITY_ACTIVE     0x0001",
            "#define ENTITY_VISIBLE    0x0002",
            "#define ENTITY_COLLIDABLE 0x0004",
            "#define ENTITY_PLAYER     0x0008",
            "#define ENTITY_ENEMY      0x0010",
            "",
            "// Entity pool",
            "static Entity entity_pool[${1:MAX_ENTITIES}];",
            "static uint32_t entity_active[(${1:MAX_ENTITIES} + 31) / 32];",
            "",
            "Entity* entity_create(void) {",
            "    for (int i = 0; i < ${1:MAX_ENTITIES}; i++) {",
            "        int word = i / 32;",
            "        int bit = i % 32;",
            "        if (!(entity_active[word] & (1 << bit))) {",
            "            entity_active[word] |= (1 << bit);",
            "            Entity* e = &entity_pool[i];",
            "            memset(e, 0, sizeof(Entity));",
            "            e->flags = ENTITY_ACTIVE;",
            "            return e;",
            "        }",
            "    }",
            "    return NULL;",
            "}",
            "",
            "void entity_destroy(Entity* entity) {",
            "    int index = entity - entity_pool;",
            "    int word = index / 32;",
            "    int bit = index % 32;",
            "    entity_active[word] &= ~(1 << bit);",
            "}"
        ],
        "description": "Complete entity component system"
    },
    // Main Game Loop
    "Main Game Loop": {
        "prefix": "dcmain",
        "body": [
            "int main(void) {",
            "    // Initialize hardware",
            "    pvr_init_defaults();",
            "    maple_init();",
            "    ",
            "    // Initialize game systems",
            "    ${1:game_init();}",
            "    ",
            "    // Main game loop",
            "    while (1) {",
            "        PROF_START(frame);",
            "        ",
            "        // Input",
            "        PROF_START(input);",
            "        maple_device_foreach(MAPLE_FUNC_CONTROLLER, update_controller);",
            "        PROF_END(input);",
            "        ",
            "        // Update",
            "        PROF_START(update);",
            "        ${2:game_update();}",
            "        PROF_END(update);",
            "        ",
            "        // Render",
            "        PROF_START(render);",
            "        pvr_wait_ready();",
            "        pvr_scene_begin();",
            "        ",
            "        pvr_list_begin(PVR_LIST_OP_POLY);",
            "        ${3:// Draw opaque objects}",
            "        pvr_list_finish();",
            "        ",
            "        pvr_list_begin(PVR_LIST_TR_POLY);",
            "        ${4:// Draw transparent objects}",
            "        pvr_list_finish();",
            "        ",
            "        pvr_scene_finish();",
            "        PROF_END(render);",
            "        ",
            "        PROF_END(frame);",
            "        ",
            "        // Check for exit",
            "        if (${5:should_exit()}) break;",
            "    }",
            "    ",
            "    // Cleanup",
            "    ${6:game_shutdown();}",
            "    pvr_shutdown();",
            "    ",
            "    return 0;",
            "}"
        ],
        "description": "Complete main game loop structure"
    }
}